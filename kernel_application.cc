#include <iostream>
#include <vector>
#include <cmath>
#include <fstream>
#include <string>

using namespace std;

typedef unsigned char u8;
typedef vector<vector<float>> mat;

// Functions used to process the images

inline int clip(int x, int xmin, int xmax) {return max(xmin,min(xmax,x)); }

inline int getPixelNo(int height, int width, int x, int y) {
  int xx{ clip(x, 0, width  - 1) };
  int yy{ clip(y, 0, height - 1) };
  return 3 * (xx + yy * width);
}

vector <u8> processImage(const vector <u8> &imageData, int height, int width, vector <vector <float>> weights) {
  vector <u8> resImage (imageData.size(), 255);
  int idx{ 0 }, kernHalfSize{ (int)weights.size() / 2 };
  float r{ 0.0 }, g{ 0.0 }, b{ 0.0 }, iW{ 0.0 };
  for (int yim = 0; yim < height; yim++) {
    for (int xim = 0; xim < width; xim++) {
      r = g = b = 0.0;
      for (int yk = -kernHalfSize; yk <= kernHalfSize; yk++) {
        for (int xk = -kernHalfSize; xk <= kernHalfSize; xk++) {
          idx = getPixelNo(height, width, xim - xk, yim - yk);
          iW = weights[kernHalfSize - yk][kernHalfSize - xk];
          r += imageData[idx]     * iW;
          g += imageData[idx + 1] * iW;
          b += imageData[idx + 2] * iW;
        }
      }
      idx = getPixelNo(height, width, xim, yim);
      resImage[idx]     = clip((int)round(r), 0, 255);
      resImage[idx + 1] = clip((int)round(g), 0, 255);
      resImage[idx + 2] = clip((int)round(b), 0, 255);
    }
  }
  return resImage;
}


// Possible kernels

mat identity() {
	mat i = {{1}};
	
	return i;
}

mat blur() {
	mat b = {
  {1.0/9,1.0/9,1.0/9},
  {1.0/9,1.0/9,1.0/9},
  {1.0/9,1.0/9,1.0/9} };
	
	return b;
}

mat sharpen() {
	mat s = {
  { 0,-1, 0},
  {-1, 5,-1},
  { 0,-1, 0} };
	
	return s;
}

mat edgeDetect() {
	mat e = {
  {-1,-1,-1},
  {-1, 8,-1},
  {-1,-1,-1} };
	
	return e;
}

mat emboss() {
	mat e = {
  {-2,-1, 0},
  {-1, 1, 1},
  { 0, 1, 2} };
	
	return e;
}

mat gaussianBlur() {
	mat g = {
	{0.0008886514773351066, 0.0013566613118620517, 0.00191780367098833, 0.0025103228719970316, 0.003042620258895748, 0.0034147479611360866, 0.0035486428168826595, 0.0034147479611360866, 0.003042620258895748, 0.0025103228719970316, 0.00191780367098833, 0.0013566613118620517, 0.0008886514773351066}, 
  {0.0013566613118620517, 0.0020711493336202577, 0.0029278182848232145, 0.003832388745848613, 0.004645021470408228, 0.005213130869399541, 0.005417541682054079, 0.005213130869399541, 0.004645021470408228, 0.003832388745848613, 0.0029278182848232145, 0.0020711493336202577, 0.0013566613118620517}, 
  {0.00191780367098833, 0.0029278182848232145, 0.0041388227153865064, 0.005417541682054079, 0.00656629561842648, 0.007369386471966865, 0.007658345701120769, 0.007369386471966865, 0.00656629561842648, 0.005417541682054079, 0.0041388227153865064, 0.0029278182848232145, 0.00191780367098833}, 
  {0.0025103228719970316, 0.003832388745848613, 0.005417541682054079, 0.007091330046025539, 0.008594999751322403, 0.009646211284823689, 0.010024446540597216, 0.009646211284823689, 0.008594999751322403, 0.007091330046025539, 0.005417541682054079, 0.003832388745848613, 0.0025103228719970316}, 
  {0.003042620258895748, 0.004645021470408228, 0.00656629561842648, 0.008594999751322403, 0.01041751268743106, 0.011691626684437127, 0.012150064228341442, 0.011691626684437127, 0.01041751268743106, 0.008594999751322403, 0.00656629561842648, 0.004645021470408228, 0.003042620258895748}, 
  {0.0034147479611360866, 0.005213130869399541, 0.007369386471966865, 0.009646211284823689, 0.011691626684437127, 0.013121571207027808, 0.013636077959481905, 0.013121571207027808, 0.011691626684437127, 0.009646211284823689, 0.007369386471966865, 0.005213130869399541, 0.0034147479611360866}, 
  {0.0035486428168826595, 0.005417541682054079, 0.007658345701120769, 0.010024446540597216, 0.012150064228341442, 0.013636077959481905, 0.014170758911667438, 0.013636077959481905, 0.012150064228341442, 0.010024446540597216, 0.007658345701120769, 0.005417541682054079, 0.0035486428168826595}, 
  {0.0034147479611360866, 0.005213130869399541, 0.007369386471966865, 0.009646211284823689, 0.011691626684437127, 0.013121571207027808, 0.013636077959481905, 0.013121571207027808, 0.011691626684437127, 0.009646211284823689, 0.007369386471966865, 0.005213130869399541, 0.0034147479611360866}, 
  {0.003042620258895748, 0.004645021470408228, 0.00656629561842648, 0.008594999751322403, 0.01041751268743106, 0.011691626684437127, 0.012150064228341442, 0.011691626684437127, 0.01041751268743106, 0.008594999751322403, 0.00656629561842648, 0.004645021470408228, 0.003042620258895748}, 
  {0.0025103228719970316, 0.003832388745848613, 0.005417541682054079, 0.007091330046025539, 0.008594999751322403, 0.009646211284823689, 0.010024446540597216, 0.009646211284823689, 0.008594999751322403, 0.007091330046025539, 0.005417541682054079, 0.003832388745848613, 0.0025103228719970316}, 
  {0.00191780367098833, 0.0029278182848232145, 0.0041388227153865064, 0.005417541682054079, 0.00656629561842648, 0.007369386471966865, 0.007658345701120769, 0.007369386471966865, 0.00656629561842648, 0.005417541682054079, 0.0041388227153865064, 0.0029278182848232145, 0.00191780367098833}, 
  {0.0013566613118620517, 0.0020711493336202577, 0.0029278182848232145, 0.003832388745848613, 0.004645021470408228, 0.005213130869399541, 0.005417541682054079, 0.005213130869399541, 0.004645021470408228, 0.003832388745848613, 0.0029278182848232145, 0.0020711493336202577, 0.0013566613118620517}, 
  {0.0008886514773351066, 0.0013566613118620517, 0.00191780367098833, 0.0025103228719970316, 0.003042620258895748, 0.0034147479611360866, 0.0035486428168826595, 0.0034147479611360866, 0.003042620258895748, 0.0025103228719970316, 0.00191780367098833, 0.0013566613118620517, 0.0008886514773351066} };
	
	return g;
}

mat laplacianFilter() {
	mat l = {
	{    0,     0, 0.075,  0.05,  0.05,  0.05, 0.075,     0,     0},
  {    0,  0.05, 0.075, 0.125, 0.125, 0.125, 0.075,  0.05,     0},
  {0.075, 0.075, 0.125, 0.075,     0, 0.075, 0.125, 0.075, 0.075},
  { 0.05, 0.125, 0.075,  -0.3,-0.575,  -0.3, 0.075, 0.125,  0.05},
  { 0.05, 0.125,     0,-0.575,  -0.9,-0.575,     0, 0.125,  0.05},
  { 0.05, 0.125, 0.075,  -0.3,-0.575,  -0.3, 0.075, 0.125,  0.05},
  {0.075, 0.075, 0.125, 0.075,     0, 0.075, 0.125, 0.075, 0.075},
  {    0,  0.05, 0.075, 0.125, 0.125, 0.125, 0.075,  0.05,     0},
  {    0,     0, 0.075,  0.05,  0.05,  0.05, 0.075,     0,     0} };
	
	return l;
}

int main() {
	
	fstream input_data("raw_RGB_input.txt", std::ios_base::in);	
	vector<u8> imageData;
	
	int counter = 0;
	int a, h, w;
	
	while (input_data >> a) {
		if (counter == 0) w = a;
		else if (counter == 1) h = a;
		else imageData.push_back(a);
		counter++;
	}
	input_data.close();
	
	fstream input_kernel("kernel.txt", std::ios_base::in);
	string kernel;
	getline(input_kernel, kernel);
	input_kernel.close();
	
	cout << "Chosen kernel: " << kernel << endl;
	
	mat weights;
	
	if (kernel == "Identity") weights = identity();
	else if (kernel == "Blur") weights = blur();
	else if (kernel == "Gaussian_blur") weights = gaussianBlur();
	else if (kernel == "Sharpen") weights = sharpen();
	else if (kernel == "Emboss") weights = emboss();
	else if (kernel == "Edge_detection") weights = edgeDetect();
	else if (kernel == "Laplacian_filter") weights = laplacianFilter();
	else {
		cerr << "There was an error with the kernel choice!";
		weights = identity();
	}
		
	vector<u8> fin = processImage(imageData, h, w, weights); 
	
	fstream output_data("modified_RGB_data.txt", std::ios_base::out);
	for (int unsigned i = 0; i < fin.size()-1; i++) {
		output_data << (int)fin[i] << ", ";
	}
	output_data << (int)fin[fin.size()-1];
	output_data.close();
	
	return 0;


}
